/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi_mod.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/08 12:50:49 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 15:44:26 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	ft_atoi_mod(char *str)
{
	int		i;
	long	result;
	int		sign;

	result = 0;
	sign = 1;
	i = 0;
	while (str[i] == 32 || (str[i] <= 13 && str[i] >= 9))
		i++;
	if (str[i] == '+' || str[i] == '-')
	{
		if (str[i] == '-')
			sign = -1;
		i++;
		if (str[i] == '+' || str[i] == '-')
		{
			ft_printf_fd(2, "Error_sign\n");
			exit(1);
			//return (write(2, "Error\n", 6), 1);
		}
	}
	// if (!(str[i] >= '0' && str[i] <= '9'))
	// 	return (write(2, "Error\n", 6), 1);
	while (str[i] >= '0' && str[i] <= '9')
	{
		result = (10 * result) + (str[i] - '0');
		i++;
	}
	if (str[i] != '\0')
	{
		ft_printf_fd(2, "Error\n");
		exit(1);
		//return (write(2, "Error\n", 6), 1);
	}
	if ((sign * result) > 2147483647 || (sign * result) < -2147483648)
	{
		ft_printf_fd(2, "Error\n");
		exit(1);
		//return (write(2, "Error\n", 6), 1);
	}
	return ((int)(sign * result));
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bucket_sort.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/16 17:52:45 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:52:49 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	get_bucket_size(int n)
{
	if (n <= 10)
		return (5);
	else if (n <= 100)
		return (15);
	else if (n <= 500)
		return (45);
	else
		return (n / 15);
}

void	transfert_a_to_b(StackElement **a, StackElement **b,
		t_count_operations *ops)
{
	int	i;
	int	range;
	int	total_elements;

	i = 0;
	total_elements = stack_size(*a);
	range = get_bucket_size(total_elements);
	while (*a != NULL)
	{
		if ((*a)->index <= i)
		{
			pb(a, b, ops);
			rb(b, ops);
			i++;
		}
		else if ((*a)->index <= i + range)
		{
			pb(a, b, ops);
			i++;
		}
		else
			ra(a, ops);
	}
}

int	find_max_index(StackElement *b)
{
	int	max;

	max = b->index;
	while (b)
	{
		if (b->index > max)
			max = b->index;
		b = b->next;
	}
	return (max);
}

void	push_b_to_a(StackElement **b, StackElement **a, t_count_operations *ops)
{
	int	max_val;
	int	pos;
	int	size;

	while (*b)
	{
		max_val = find_max_index(*b);
		pos = get_pos(*b, max_val);
		size = stack_size(*b);
		if (pos <= size / 2)
		{
			while ((*b)->index != max_val)
				rb(b, ops);
		}
		else
		{
			while ((*b)->index != max_val)
				rrb(b, ops);
		}
		pa(a, b, ops);
	}
}

void	bucket_sort(StackElement **a, t_count_operations *ops)
{
	StackElement	*b;

	b = NULL;
	indexation(a);
	transfert_a_to_b(a, &b, ops);
	push_b_to_a(&b, a, ops);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_flags_check.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:48:29 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:02 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

t_count_flag	ft_count_flags(int argc, char **argv)
{
	int				i;
	t_count_flag	j;

	i = 1;
	j.complex = 0;
	j.simple = 0;
	j.medium = 0;
	j.bench = 0;
	j.adaptive = 0;
	while (i < argc)
	{
		if (isbench(argv[i]))
			j.bench += 1;
		if (issimple(argv[i]))
			j.simple += 1;
		if (ismedium(argv[i]))
			j.medium += 1;
		if (iscomplex(argv[i]))
			j.complex += 1;
		if (isadaptive(argv[i]))
			j.adaptive += 1;
		i++;
	}
	return (j);
}

int	check_flags(t_count_flag j)
{
	if (j.simple > 0 && (j.medium > 0 || j.complex > 0 || j.adaptive > 0))
	{
		ft_printf_fd(2, "erreur\n");
		return (0);
	}
	if (j.medium > 0 && (j.complex > 0 || j.adaptive > 0))
	{
		ft_printf_fd(2, "erreur\n");
		return (0);
	}
	if (j.complex > 0 && j.adaptive > 0)
	{
		ft_printf_fd(2, "erreur\n");
		return (0);
	}
	else
		return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_flags_detect.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:48:04 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:03 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	isbench(char *s)
{
	int		i;
	char	*f;

	i = 0;
	f = "--bench";
	if (!s)
		return (0);
	while (s[i] == f[i] && f[i] != '\0')
		i++;
	if (s[i] == '\0' && f[i] == '\0')
		return (1);
	else
		return (0);
}

int	issimple(char *s)
{
	int		i;
	char	*f;

	i = 0;
	f = "--simple";
	if (!s)
		return (0);
	while (s[i] == f[i] && f[i] != '\0')
		i++;
	if (s[i] == '\0' && f[i] == '\0')
		return (1);
	else
		return (0);
}

int	ismedium(char *s)
{
	int		i;
	char	*f;

	i = 0;
	f = "--medium";
	if (!s)
		return (0);
	while (s[i] == f[i] && f[i] != '\0')
		i++;
	if (s[i] == '\0' && f[i] == '\0')
		return (1);
	else
		return (0);
}

int	iscomplex(char *s)
{
	int		i;
	char	*f;

	i = 0;
	f = "--complex";
	if (!s)
		return (0);
	while (s[i] == f[i] && f[i] != '\0')
		i++;
	if (s[i] == '\0' && f[i] == '\0')
		return (1);
	else
		return (0);
}

int	isadaptive(char *s)
{
	int		i;
	char	*f;

	i = 0;
	f = "--adaptive";
	if (!s)
		return (0);
	while (s[i] == f[i] && f[i] != '\0')
		i++;
	if (s[i] == '\0' && f[i] == '\0')
		return (1);
	else
		return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_indexation.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/15 15:49:59 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:04 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	swaparr(int *a, int *b)
{
	int	tmp;

	tmp = *a;
	*a = *b;
	*b = tmp;
}

int	partition(int arr[], int low, int high)
{
	int	pivot;
	int	i;
	int	j;

	pivot = arr[high];
	i = low - 1;
	j = low;
	while (j < high)
	{
		if (arr[j] < pivot)
		{
			i++;
			swaparr(&arr[i], &arr[j]);
		}
		j++;
	}
	swaparr(&arr[i + 1], &arr[high]);
	return (i + 1);
}

void	quick_sort(int arr[], int low, int high)
{
	int	pi;

	pi = 0;
	if (low < high)
	{
		pi = partition(arr, low, high);
		quick_sort(arr, low, pi -1);
		quick_sort(arr, pi + 1, high);
	}
}

static void	fill_index(StackElement *a, int *arr, int n)
{
	StackElement	*curr;
	int				i;

	curr = a;
	while (curr)
	{
		i = 0;
		while (i < n)
		{
			if (arr[i] == curr->value)
			{
				curr->index = i;
				break ;
			}
			i++;
		}
		curr = curr->next;
	}
}

int	indexation(StackElement **a)
{
	int				*arr;
	int				n;
	StackElement	*curr;
	int				i;

	n = stack_size(*a);
	curr = *a;
	arr = malloc(sizeof(int) * n);
	if (!arr)
		return (1);
	i = 0;
	while (curr)
	{
		arr[i] = curr->value;
		i++;
		curr = curr->next;
	}
	quick_sort(arr, 0, n - 1);
	curr = *a;
	fill_index(*a, arr, n);
	free(arr);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_op_push.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/11 17:29:21 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:05 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void    push(StackElement **src, StackElement **dest)
{
    StackElement    *tmp;

    if (!src || !*src)
        return ;
    tmp = *src;
    *src = tmp->next;
    tmp->next = *dest;
    *dest = tmp;
}

void    pa(StackElement **a, StackElement **b, t_count_operations *ops)
{
    push(b, a);
    ops->count_pa++;
    write(1, "pa\n", 3);
}

void    pb(StackElement **a, StackElement **b, t_count_operations *ops)
{
    push(a, b);
    ops->count_pb++;
    write(1, "pb\n", 3);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_op_reverse_rotate.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/11 17:29:24 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:06 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	reverse_rotate(StackElement **s)
{
	StackElement	*prev;
	StackElement	*last;

	if (!s || !*s || !(*s)->next)
		return ;
	prev = NULL;
	last = *s;
	while (last->next)
	{
		prev = last;
		last = last->next;
	}
	prev->next = NULL;
	last->next = *s;
	*s = last;
}

void	rra(StackElement **a, t_count_operations *ops)
{
	reverse_rotate(a);
	ops->count_rra++;
	write(1, "rra\n", 4);
}

void	rrb(StackElement **b, t_count_operations *ops)
{
	reverse_rotate(b);
	ops->count_rrb++;
	write(1, "rrb\n", 4);
}

void	rrr(StackElement **a, StackElement **b, t_count_operations *ops)
{
	reverse_rotate(a);
	reverse_rotate(b);
	ops->count_rrr++;
	write(1, "rrr\n", 4);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_op_rotate.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/11 17:29:28 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:06 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void    rotate(StackElement **s)
{
    StackElement    *first;
    StackElement    *last;

    if (!s || !*s || !(*s)->next)
        return ;
    first = *s;
    *s = first->next;
    last = *s;
    while (last->next)
        last = last->next;
    last->next = first;
    first->next = NULL;
}

void    ra(StackElement **a, t_count_operations *ops)
{
    rotate(a);
    ops->count_ra++;
    write(1, "ra\n", 3);
}

void    rb(StackElement **b, t_count_operations *ops)
{
    rotate(b);
    ops->count_rb++;
    write(1, "rb\n", 3);
}

void    rr(StackElement **a, StackElement **b, t_count_operations *ops)
{
    rotate(a);
    rotate(b);
    ops->count_rr++;
    write(1, "rr\n", 3);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_op_swap.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/24 05:26:17 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:07 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "push_swap.h"

void    swap(StackElement **s)
{
    StackElement    *first;
    StackElement    *second;

    if (!s || !*s || !(*s)->next)
        return ;
    first = *s;
    second = first->next;
    first->next = second->next;
    second->next = first;
    *s = second;
}

void    sa(StackElement **a, t_count_operations *ops)
{
    swap(a);
    ops->count_sa++;
    write(1, "sa\n", 3);
}

void    sb(StackElement **b, t_count_operations *ops)
{
    swap(b);
    ops->count_sb++;
    write(1, "sb\n", 3);
}

void    ss(StackElement **a, StackElement **b, t_count_operations *ops)
{
    swap(a);
    swap(b);
    ops->count_ss++;
    write(1, "ss\n", 3);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_parse_args.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:48:43 by mledda            #+#    #+#             */
/*   Updated: 2026/02/04 14:32:05 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

char	*ft_strjoin_space(char const *s1, char const *s2)
{
	char	*s3;
	size_t	i;
	size_t	j;

	if (!s1 && !s2)
		return (ft_strdup(""));
	if (!s1)
		return (ft_strdup(s2));
	if (!s2)
		return (ft_strdup(s1));
	i = 0;
	j = 0;
	s3 = (char *)malloc((ft_strlen(s1) + ft_strlen(s2) + 2) * sizeof(char));
	if (!s3)
		return (NULL);
	while (s1[i] != '\0')
		s3[j++] = s1[i++];
	s3[j++] = ' ';
	i = 0;
	while (s2[i] != '\0')
		s3[j++] = s2[i++];
	s3[j] = '\0';
	return (s3);
}

char	*add_argv(int argc, char **argv)
{
	int		i;
	char	*s_total;
	char	*temp;

	s_total = ft_strdup("");
	i = 1;
	while (i < argc)
	{
		if (!isbench(argv[i]) && !issimple(argv[i]) && !ismedium(argv[i])
			&& !iscomplex(argv[i]) && !isadaptive(argv[i]))
		{
			temp = s_total;
			s_total = ft_strjoin_space(temp, argv[i]);
			free(temp);
		}
		i++;
	}
	return (s_total);
}

int	check_s(char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
	{
		if (s[i] == '+' || s[i] == '-'
			|| (s[i] <= '9' && s[i] >= '0') || s[i] == ' ')
			i++;
		else
			return (0);
	}
	return (1);
}[31m[bat error][0m: 'ft_printf_fd' is a directory.
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_radix_sort.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/16 18:07:27 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:09 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

static int	get_max_bits(StackElement *stack)
{
	int	max_index;
	int	max_bits;

	max_index = 0;
	max_bits = 0;
	while (stack)
	{
		if (stack->index > max_index)
			max_index = stack->index;
		stack = stack->next;
	}
	while ((max_index >> max_bits) != 0)
		max_bits++;
	return (max_bits);
}

void	radix_sort(StackElement **a, t_count_operations *ops)
{
	int				i;
	int				j;
	int				size;
	int				max_bits;
	StackElement	*current;
	StackElement	*b;

	b = NULL;
	i = 0;
	size = stack_size(*a);
	max_bits = get_max_bits(*a);
	while (i < max_bits)
	{
		j = 0;
		while (j < size)
		{
			current = *a;
			if (((current->index >> i) & 1) == 1)
				ra(a, ops);
			else
				pb(a, &b, ops);
			j++;
		}
		while (b)
			pa(a, &b, ops);
		i++;
	}
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_sort_dispatcher.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/26 14:28:38 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:53:09 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

float	compute_disorder_indexed(StackElement *a)
{
	long			mistakes;
	long			total;
	StackElement	*outer;
	StackElement	*inner;

	if (!a || !a->next)
		return (0.0);
	mistakes = 0;
	total = 0;
	outer = a;
	while (outer->next)
	{
		inner = outer->next;
		while (inner)
		{
			total++;
			if (outer->index > inner->index)
				mistakes++;
			inner = inner->next;
		}
		outer = outer->next;
	}
	return ((float)mistakes / total);
}

static const char	*get_strategy_label(float disorder, t_count_flag flags)
{
	if (flags.simple)
		return ("Simple sort / O(nÂ²)");
	if (flags.medium)
		return ("Bucket sort / O(nâˆšn)");
	if (flags.complex)
		return ("Radix sort / O(n log n)");
	if (disorder < 0.2)
		return ("Adaptive -> Simple sort / O(nÂ²)");
	if (disorder < 0.5)
		return ("Adaptive -> Bucket sort / O(nâˆšn)");
	return ("Adaptive -> Radix sort / O(n log n)");
}

static void	print_bench(t_count_operations *ops, float disorder,
		t_count_flag flags)
{
	int	total;

	total = ops->count_pa + ops->count_pb + ops->count_sa + ops->count_sb
		+ ops->count_ss + ops->count_ra + ops->count_rb + ops->count_rr
		+ ops->count_rra + ops->count_rrb + ops->count_rrr;
	ft_printf_fd(2, "[bench] disorder:   %f%%\n", disorder * 100);
	ft_printf_fd(2, "[bench] strategy:   %s\n",
		get_strategy_label(disorder, flags));
	ft_printf_fd(2, "[bench] total_ops:  %d\n", total);
	ft_printf_fd(2, "[bench] sa: %d  sb: %d  ss: %d  pa: %d  pb: %d\n",
		ops->count_sa, ops->count_sb, ops->count_ss,
		ops->count_pa, ops->count_pb);
	ft_printf_fd(2, "[bench] ra: %d  rb: %d  rr: %d  rra: %d  rrb: %d  rrr: %d\n",
		ops->count_ra, ops->count_rb, ops->count_rr,
		ops->count_rra, ops->count_rrb, ops->count_rrr);
}

static void	execute_sort(StackElement **a, t_count_operations *ops,
		t_count_flag flags)
{
	float	disorder;

	disorder = compute_disorder_indexed(*a);
	if (flags.simple)
		simple_sort(a, ops);
	else if (flags.medium)
		bucket_sort(a, ops);
	else if (flags.complex)
		radix_sort(a, ops);
	else
	{
		if (disorder < 0.2)
			simple_sort(a, ops);
		else if (disorder < 0.5)
			bucket_sort(a, ops);
		else
			radix_sort(a, ops);
	}
	if (flags.bench)
		print_bench(ops, disorder, flags);
}

void	choose_sort(StackElement **a, t_count_operations *ops,
		t_count_flag flags)
{
	execute_sort(a, ops, flags);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_sort_small.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/11 17:29:12 by tlopez            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:11 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	find_pos(StackElement *a, int value)
{
	int	i;

	i = 0;
	while (a)
	{
		if (a->value == value)
			return (i);
		a = a->next;
		i++;
	}
	return (-1);
}

void	bring_to_top(StackElement **a, int pos, t_count_operations *ops)
{
	int	size;

	size = stack_size(*a);
	if (pos <= size / 2)
	{
		while (pos-- > 0)
			ra(a, ops);
	}
	else
	{
		while (pos++ < size)
			rra(a, ops);
	}
}

void	sort_three(StackElement **a, t_count_operations *ops)
{
	int	x;
	int	y;
	int	z;

	x = (*a)->value;
	y = (*a)->next->value;
	z = (*a)->next->next->value;
	if (x > y && y < z && x < z)
		sa(a, ops);
	else if (x > y && y > z)
	{
		sa(a, ops);
		rra(a, ops);
	}
	else if (x > y && y < z && x > z)
		ra(a, ops);
	else if (x < y && y > z && x < z)
	{
		sa(a, ops);
		ra(a, ops);
	}
	else if (x < y && y > z && x > z)
		rra(a, ops);
}

void	simple_sort(StackElement **a, t_count_operations *ops)
{
    int				min;
    int				pos;
    StackElement	*b;

    b = NULL;
    if (is_sorted(*a))
        return ;
    while (stack_size(*a) > 3)
    {
        min = find_min(*a);
        pos = find_pos(*a, min);
        bring_to_top(a, pos, ops);
        pb(a, &b, ops);
    }
    sort_three(a, ops);
    while (b)
        pa(a, &b, ops);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_stack_core.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:48:18 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:12 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

Stack	new_stack(void)
{
	return (NULL);
}

Bool	is_empty_stack(Stack st)
{
	if (st == NULL)
		return (true);
	return (false);
}

int	stack_size(StackElement *s)
{
	int	count;

	count = 0;
	while (s)
	{
		count++;
		s = s->next;
	}
	return (count);
}

void	print_stack(Stack st)
{
	while (!is_empty_stack(st))
	{
		ft_printf_fd(2, "%d\n", st->value);
		st = st->next;
	}
}

StackElement	*new_node(int value)
{
	StackElement	*new;

	new = malloc(sizeof(StackElement));
	if (!new)
		return (NULL);
	new->value = value;
	new->next = NULL;
	return (new);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_stack_init.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:19:32 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 15:28:44 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	free_stack(StackElement *lst)
{
	StackElement	*tmp;

	while (lst)
	{
		tmp = lst->next;
		free(lst);
		lst = tmp;
	}
}

int	no_duplicate(StackElement *a)
{
	StackElement	*current;
	StackElement	*runner;

	current = a;
	while (current != NULL)
	{
		runner = current->next;
		while (runner != NULL)
		{
			if (current->value == runner->value)
			{
				//printf("cc");
				ft_printf_fd(2, "duplicate\n");
				return (1);
			}
			runner = runner->next;
		}
		current = current->next;
	}
	return (0);
}

void	free_split(char **arrays)
{
	size_t	i;

	i = 0;
	if (!arrays)
		return ;
	while (arrays[i])
	{
		free(arrays[i]);
		i++;
	}
	free(arrays);
}

static StackElement	*build_stack(char **arr)
{
	StackElement	*first;
	StackElement	*cur;
	int				i;
	int				value;

	value = ft_atoi_mod(arr[0]);
	if (!value)
		return (NULL);
	first = new_node(value);
	if (!first)
		return (NULL);
	cur = first;
	i = 0;
	while (arr[++i])
	{
		value = ft_atoi_mod(arr[i]);
		if (!value)
			return (free_stack(first), NULL);
		cur->next = new_node(value);
		if (!cur->next)
			return (free_stack(first), NULL);
		cur = cur->next;
	}
	return (first);
}

StackElement	*stack_a(char *s)
{
	StackElement	*stack;
	char			**arr;

	arr = ft_split(s, ' ');
	if (!arr || !arr[0])
		return (NULL);
	stack = build_stack(arr);
	if (!stack)
	{
		return(free_stack(stack), NULL);
	}
	free_split(arr);
	if (!stack || no_duplicate(stack) == 1)
	{	
		return (free_stack(stack), NULL);
	}
	return (stack);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_stack_pos.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/16 19:21:26 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:13 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	get_pos(StackElement *stack, int target_index)
{
	int	pos;

	pos = 0;
	while (stack)
	{
		if (stack->index == target_index)
			return (pos);
		pos++;
		stack = stack->next;
	}
	return (pos);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_stack_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/15 16:29:55 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:14 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	find_min(StackElement *a)
{
	int	min;

	min = a->value;
	while (a)
	{
		if (a->value < min)
			min = a->value;
		a = a->next;
	}
	return (min);
}

int	find_max(StackElement *a)
{
	int	max;

	max = a->value;
	while (a)
	{
		if (a->value > max)
			max = a->value;
		a = a->next;
	}
	return (max);
}

int	is_sorted(StackElement *a)
{
	while (a && a->next)
	{
		if (a->value > a->next->value)
			return (0);
		a = a->next;
	}
	return (1);
}[31m[bat error][0m: 'libft' is a directory.
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:47:50 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 15:42:22 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

void	init_operations(t_count_operations *ops)
{
	ops->count_pa = 0;
	ops->count_pb = 0;
	ops->count_sa = 0;
	ops->count_sb = 0;
	ops->count_ss = 0;
	ops->count_ra = 0;
	ops->count_rb = 0;
	ops->count_rr = 0;
	ops->count_rra = 0;
	ops->count_rrb = 0;
	ops->count_rrr = 0;
}

int	main(int argc, char **argv)
{
	char				*s;
	StackElement		*a;
	t_count_operations	ops;
	t_count_flag		flags;

	s = NULL;
	init_operations(&ops);
	flags = ft_count_flags(argc, argv);
	if (check_flags(flags) == 0)
		return (0);
	s = add_argv(argc, argv);
	if (!s)
		return (0);
	if (check_s(s) == 0)
		return (ft_printf_fd(2, "ERROR\n"), free(s), 0);
	a = stack_a(s);
	print_stack(a);
	free(s);
	if (!a)
		return (0);
	indexation(&a);
	choose_sort(&a, &ops, flags);
	print_stack(a);
	free_stack(a);
	return (0);
}# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2026/02/16 20:03:43 by mledda            #+#    #+#              #
#    Updated: 2026/02/28 03:14:01 by tlopez           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME = push_swap
LIBFT_DIR = ./libft
FT_PRINTF_FD_DIR = ./ft_printf_fd

SRC  =  ft_parse_args.c ft_flags_check.c ft_stack_init.c ft_stack_core.c \
        ft_flags_detect.c main.c ft_op_push.c \
        ft_op_reverse_rotate.c ft_op_rotate.c ft_op_swap.c ft_atoi_mod.c \
        ft_indexation.c ft_stack_utils.c \
        ft_bucket_sort.c ft_stack_pos.c ft_radix_sort.c ft_sort_small.c \
        ft_sort_dispatcher.c
		
OBJ		= $(SRC:.c=.o)

LIBFT_A = $(LIBFT_DIR)/libft.a
FT_PRINTF_FD_A = $(FT_PRINTF_FD_DIR)/ft_printf_fd.a

CC	= cc
CFLAGS	= -Wall -Wextra -Werror -I. -I$(LIBFT_DIR) -I$(FT_PRINT_FD_DIR) -fsanitize=address,undefined,leak -g3 -std=c99
RM	= rm -f

all: $(NAME)

$(NAME): $(OBJ) $(LIBFT_A) $(FT_PRINTF_FD_A)
	$(CC) $(CFLAGS) $(OBJ) $(LIBFT_A) $(FT_PRINTF_FD_A) -o $(NAME)
	
%.o: %.c libft.h push_swap.h ft_printf_fd.h
	$(CC) $(CFLAGS) -c $< -o $@

$(LIBFT_A):
	@$(MAKE) -C $(LIBFT_DIR)
	
$(FT_PRINTF_FD_A):
	@$(MAKE) -C $(FT_PRINTF_FD_DIR)

clean:
	$(RM) $(OBJ)
	@$(MAKE) -C $(LIBFT_DIR) clean
	@$(MAKE) -C $(FT_PRINTF_FD_DIR) clean

fclean: clean
	$(RM) $(NAME)
	@$(MAKE) -C $(LIBFT_DIR) fclean
	@$(MAKE) -C $(FT_PRINTF_FD_DIR) fclean

re: fclean all

.PHONY: all clean fclean re
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 11:47:37 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:13:16 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include "libft/libft.h"
#include "ft_printf_fd/ft_printf_fd.h"

typedef struct s_count_flags
{
	int bench;
	int simple;
	int medium;
	int complex;
	int adaptive;
}	t_count_flag;

typedef enum
{
	false,
	true
}	Bool;

typedef struct StackElement
{
	int					index;
	int					value;
	struct StackElement	*prev;
	struct StackElement	*next;
}	StackElement, *Stack;

typedef struct s_count_operations
{
	int	count_pa;
	int	count_pb;
	int	count_sa;
	int	count_sb;
	int	count_ss;
	int	count_ra;
	int	count_rb;
	int	count_rr;
	int	count_rra;
	int	count_rrb;
	int	count_rrr;
}	t_count_operations;

/* flags */
int					isbench(char *s);
int					issimple(char *s);
int					ismedium(char *s);
int					iscomplex(char *s);
int					isadaptive(char *s);
int					check_flags(t_count_flag j);
t_count_flag		ft_count_flags(int argc, char **argv);

/* stack basics */
Stack				new_stack(void);
Bool				is_empty_stack(Stack st);
StackElement		*new_node(int value);
void				free_stack(StackElement *lst);
int					stack_size(StackElement *s);
void				print_stack(Stack st);

/* stack creation */
StackElement		*stack_a(char *s);
int					no_duplicate(StackElement *a);
void				free_split(char **arrays);

/* utils */
char				*ft_strjoin_space(char const *s1, char const *s2);
char				*ft_strdup(const char *s);
size_t				ft_strlen(const char *str);
char				*add_argv(int argc, char **argv);
int					check_s(char *s);
char				**ft_split(char const *s, char c);
int					ft_atoi(const char *str);
int					ft_atoi_mod(char *str);

/* indexation */
void				swaparr(int *a, int *b);
int					partition(int arr[], int low, int high);
void				quick_sort(int arr[], int low, int high);
int					indexation(StackElement **a);

/* sort helpers */
int					find_min(StackElement *a);
int					find_max(StackElement *a);
int					is_sorted(StackElement *a);
int					get_bucket_size(int n);
int					find_max_index(StackElement *b);
int					get_pos(StackElement *stack, int target_index);
void				choose_sort(StackElement **a, t_count_operations *ops, t_count_flag flags);

/* operations - swap */
void				swap(StackElement **s);
void				sa(StackElement **a, t_count_operations *ops);
void				sb(StackElement **b, t_count_operations *ops);
void				ss(StackElement **a, StackElement **b, t_count_operations *ops);

/* operations - push */
void				push(StackElement **src, StackElement **dest);
void				pa(StackElement **a, StackElement **b, t_count_operations *ops);
void				pb(StackElement **a, StackElement **b, t_count_operations *ops);

/* operations - rotate */
void				rotate(StackElement **s);
void				ra(StackElement **a, t_count_operations *ops);
void				rb(StackElement **b, t_count_operations *ops);
void				rr(StackElement **a, StackElement **b, t_count_operations *ops);

/* operations - reverse rotate */
void				reverse_rotate(StackElement **s);
void				rra(StackElement **a, t_count_operations *ops);
void				rrb(StackElement **b, t_count_operations *ops);
void				rrr(StackElement **a, StackElement **b, t_count_operations *ops);

/* sorts */
void				transfert_a_to_b(StackElement **a, StackElement **b, t_count_operations *ops);
void				push_b_to_a(StackElement **b, StackElement **a, t_count_operations *ops);
void				bucket_sort(StackElement **a, t_count_operations *ops);
void				radix_sort(StackElement **a, t_count_operations *ops);
void				bring_to_top(StackElement **a, int pos, t_count_operations *ops);
void				sort_three(StackElement **a, t_count_operations *ops);
void				simple_sort(StackElement **a, t_count_operations *ops);

/* operations counter */
void				init_operations(t_count_operations *ops);
void				print_operations(t_count_operations *ops);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/16 11:25:05 by mledda            #+#    #+#             */
/*   Updated: 2025/11/16 11:49:19 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

int	ft_atoi(const char *str)
{
	int	i;
	int	result;
	int	sign;

	result = 0;
	sign = 1;
	i = 0;
	while (str[i] == 32 || (str[i] <= 13 && str[i] >= 9))
		i++;
	if (str[i] == '+' && str[i + 1] != '-')
		i++;
	if (str[i] == '-')
	{
		sign = -sign;
		i++;
	}
	while (str[i] <= '9' && str[i] >= '0')
	{
		result = (10 * result) + (str[i] - '0');
		i++;
	}
	return (sign * result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/16 12:01:47 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:34:05 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	unsigned char	*p;
	size_t			i;
	size_t			total;

	total = nmemb * size;
	i = 0;
	if (nmemb != 0 && total / nmemb != size)
		return (NULL);
	p = malloc(total);
	if (p == NULL)
		return (NULL);
	while (i < total)
	{
		p[i] = 0;
		i++;
	}
	return (p);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <marvin@42.fr>                      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/05 16:57:19 by mledda            #+#    #+#             */
/*   Updated: 2025/11/09 18:19:06 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	else
		return (0);
}

/*
#include <stdio.h>

int	main(void)
{
	int l = 1;

	while(l != EOF)
	{
		write(1,"Entrez un chiffre: ", 19);
		l = getchar();
		if (ft_isdigit(l))
			write(1, "\nIs digit\n", 10);
		else
			write(1, "\nNot digit\n", 11);
		getchar();
	}
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/26 11:41:52 by mledda            #+#    #+#             */
/*   Updated: 2025/11/26 11:47:30 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static size_t	count_world(char const *s, char c)
{
	size_t	count;
	size_t	i;

	count = 0;
	i = 0;
	while (s[i])
	{
		while (s[i] && s[i] == c)
			i++;
		if (s[i] && s[i] != c)
			count++;
		while (s[i] && s[i] != c)
			i++;
	}
	return (count);
}

static char	*copy_world_of_index(char const *s, char c, size_t index)
{
	size_t	count;
	size_t	i;
	size_t	start;

	count = 0;
	i = 0;
	while (s[i])
	{
		while (s[i] && s[i] == c)
			i++;
		if (s[i] && s[i] != c)
			count++;
		if (s[i] && index == count)
		{
			start = i;
			while (s[i] && s[i] != c)
				i++;
			return (ft_substr(s, start, (i - start)));
		}
		while (s[i] && s[i] != c)
			i++;
	}
	return (NULL);
}

char	**ft_split(char const *s, char c)
{
	char	**arrays;
	size_t	count;
	size_t	j;

	j = 0;
	if (s == NULL)
		return (NULL);
	count = count_world(s, c);
	arrays = (char **)ft_calloc(sizeof (char *), (count + 1));
	if (!arrays)
		return (NULL);
	arrays[count] = 0;
	while ((j + 1) <= count)
	{
		arrays[j] = copy_world_of_index (s, c, (j + 1));
		if (arrays[j] == NULL)
			return (NULL);
		j++;
	}
	return (arrays);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/16 13:49:51 by mledda            #+#    #+#             */
/*   Updated: 2025/11/19 16:44:51 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strdup(const char *s)
{
	char		*s1;
	size_t		i;

	i = 0;
	s1 = (char *) malloc ((ft_strlen(s) + 1));
	if (!s1)
		return (NULL);
	while (s[i])
	{
		s1[i] = s[i];
		i++;
	}
	s1[i] = '\0';
	return (s1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/16 17:21:25 by mledda            #+#    #+#             */
/*   Updated: 2025/11/19 18:54:56 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	char	*s3;
	size_t	i;
	size_t	j;

	if (!s1 && !s2)
		return (ft_strdup(""));
	if (!s1)
		return (ft_strdup(s2));
	if (!s2)
		return (ft_strdup(s1));
	i = 0;
	j = 0;
	s3 = (char *) malloc ((ft_strlen(s1) + ft_strlen(s2) + 1) * sizeof(char));
	if (!s3)
		return (NULL);
	while (s1[i] != '\0')
		s3[j++] = s1[i++];
	i = 0;
	while (s2[i] != '\0')
		s3[j++] = s2[i++];
	s3[j] = '\0';
	return (s3);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/11 12:33:45 by mledda            #+#    #+#             */
/*   Updated: 2025/11/11 12:46:57 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h" 

size_t	ft_strlen(const char *str)
{
	size_t	i;

	i = 0;
	while (str[i] != '\0')
		i++;
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/16 14:40:55 by mledda            #+#    #+#             */
/*   Updated: 2025/11/19 18:23:24 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	char	*s1;
	size_t	i;

	i = 0;
	if (!s)
		return (NULL);
	if (start > ft_strlen(s))
		return (ft_strdup(""));
	if ((start + len) > ft_strlen(s))
		s1 = (char *) malloc (((ft_strlen(s) - start) + 1) * sizeof(char));
	else
		s1 = (char *) malloc((len +1) * sizeof(char));
	if (!s1)
		return (NULL);
	while (i < len && start < ft_strlen(s) && s[start + i])
	{
		s1[i] = s[start + i];
		i++;
	}
	s1[i] = '\0';
	return (s1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/09 14:49:19 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:36:37 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H
# include <unistd.h>
# include <stdlib.h>

size_t	ft_strlen(const char *str);
int		ft_isdigit(int c);
int		ft_atoi(const char *str);
void	*ft_calloc(size_t nmemb, size_t size);
char	*ft_strdup(const char *s);
char	*ft_substr(char const *s, unsigned int start, size_t len);
char	*ft_strjoin(char const *s1, char const *s2);
char	**ft_split(char const *s, char c);

#endifNAME	= libft.a

CC	= cc
CFLAGS	= -Wall -Wextra -Werror
AR	= ar rcs
RM	= rm -f

SRC	=	ft_atoi.c ft_calloc.c ft_strdup.c ft_substr.c \
		ft_strjoin.c ft_split.c ft_strlen.c ft_isdigit.c \

OBJ	= $(SRC:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
	$(AR) $(NAME) $(OBJ)

%.o: %.c libft.h
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	$(RM) $(OBJ)

fclean: clean
	$(RM) $(NAME)

re: fclean all

.PHONY: all clean fclean re/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_adress_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:20:38 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:32:43 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_adress_fd(int fd, void const *p)
{
	int	i;

	i = 0;
	if (!p)
		i += ft_putstrcount_fd(fd, "(nil)");
	else
	{
		i += ft_putstrcount_fd(fd, "0x");
		i += ft_puthexacount_fd(fd, (unsigned long)p);
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: tlopez <tlopez@student.42nice.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:20:56 by mledda            #+#    #+#             */
/*   Updated: 2026/02/28 03:33:25 by tlopez           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_printf_fd(int fd, const char *format, ...)
{
	int		i;
	int		count;
	va_list	ap;

	i = 0;
	count = 0;
	va_start(ap, format);
	if (!format)
	{
		va_end(ap);
		return (0);
	}
	while (format[i])
	{
		if (format[i] == '%')
		{
			i++;
			count += ft_which_index(fd, format[i], ap);
		}
		else
			count += write(fd, &format[i], 1);
		i++;
	}
	va_end(ap);
	return (count);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_printf_fd.h                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/03 12:45:54 by mledda            #+#    #+#             */
/*   Updated: 2026/02/26 17:15:22 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FT_PRINTF_FD_H
# define FT_PRINTF_FD_H
# include <unistd.h>
# include <stdlib.h>
# include <stdarg.h>

int		ft_printf_fd(int fd, const char *format, ...);
int		ft_which_index(int fd, char c, va_list ap);
int		ft_putstrcount_fd(int fd, const char *s);
int		ft_putnbrcount_fd(int fd, int n);
int		ft_putcharcount_fd(int fd, char c);
int		ft_puthexacount_fd(int fd, unsigned long n);
int		ft_putuphexacount_fd(int fd, unsigned int n);
int		ft_putnbru_fd(int fd, unsigned int n);
int		ft_adress_fd(int fd, void const *p);
int 	ft_putfloat_fd(int fd, double n, int precision);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putcharcount_fd.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:23:33 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:23:51 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_putcharcount_fd(int fd, char c)
{
	write(fd, &c, 1);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putfloat_fd.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/26 17:01:37 by mledda            #+#    #+#             */
/*   Updated: 2026/02/26 17:19:51 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_putfloat_fd(int fd, double n, int precision)
{
	long	int_part;
	double	diff;
	int		digit;

	int_part = (long)n;
	diff = n - (double)int_part;
	ft_putnbrcount_fd(fd, int_part);
	write(fd, ".", 1);
	while (precision--)
	{
		diff *= 10;
		digit = (int)diff;
		ft_putcharcount_fd(fd, digit + '0');
		diff -= digit;
	}
	return(0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_puthexacount_fd.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:24:34 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:25:47 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_puthexacount_fd(int fd, unsigned long n)
{
	char	*base;
	int		i;

	base = "0123456789abcdef";
	i = 0;
	if (n < 16)
		i += ft_putcharcount_fd(fd, base[n]);
	else
	{
		i += ft_puthexacount_fd(fd, n / 16);
		i += ft_puthexacount_fd(fd, n % 16);
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbrcount_fd.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/07 12:58:33 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:25:57 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_putnbrcount_fd(int fd, int n)
{
	long	nb;
	int		i;

	nb = n;
	i = 0;
	if (nb < 0)
	{
		i += ft_putcharcount_fd(fd, '-');
		nb = -nb;
	}
	if (nb < 10)
		i += ft_putcharcount_fd(fd, nb + 48);
	else
	{
		i += ft_putnbrcount_fd(fd, nb / 10);
		i += ft_putnbrcount_fd(fd, nb % 10);
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbru_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:26:24 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:26:30 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_putnbru_fd(int fd, unsigned int n)
{
	int				i;
	unsigned long	nb;

	nb = n;
	i = 0;
	if (nb <= 9)
		i += ft_putcharcount_fd(fd, nb + 48);
	else
	{
		i += ft_putnbru_fd(fd, nb / 10);
		i += ft_putnbru_fd(fd, nb % 10);
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstrcount_fd.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:26:54 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:26:57 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

void	ft_putchar_fd(int fd, char c)
{
	write(fd, &c, 1);
}

int	ft_putstrcount_fd(int fd, const char *s)
{
	int	i;

	i = 0;
	if (!s)
	{
		write(fd, "(null)", 6);
		return (6);
	}
	while (s[i] != '\0')
	{
		ft_putchar_fd(fd, s[i]);
		i++;
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putuphexacount_fd.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/22 15:27:17 by mledda            #+#    #+#             */
/*   Updated: 2026/02/22 15:27:26 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"

int	ft_putuphexacount_fd(int fd, unsigned int n)
{
	char	*base;
	int		i;

	base = "0123456789ABCDEF";
	i = 0;
	if (n < 16)
		i += ft_putcharcount_fd(fd, base[n]);
	else
	{
		i += ft_putuphexacount_fd(fd, (n / 16));
		i += ft_putuphexacount_fd(fd, (n % 16));
	}
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_which_index.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mledda <mledda@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/03 14:00:12 by mledda            #+#    #+#             */
/*   Updated: 2026/02/26 17:18:56 by mledda           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "ft_printf_fd.h"
#include <stdio.h> 

int	ft_which_index(int fd, char c, va_list ap)
{
	if (c == 'c')
		return (ft_putcharcount_fd(fd, va_arg(ap, int)));
	if (c == 'd' || c == 'i')
		return (ft_putnbrcount_fd(fd, va_arg(ap, int)));
	if (c == 's')
		return (ft_putstrcount_fd(fd, va_arg(ap, char *)));
	if (c == 'p')
		return (ft_adress_fd(fd, va_arg(ap, void *)));
	if (c == 'u')
		return (ft_putnbru_fd(fd, va_arg(ap, unsigned int)));
	if (c == 'x')
		return (ft_puthexacount_fd(fd, va_arg(ap, unsigned int)));
	if (c == 'X')
		return (ft_putuphexacount_fd(fd, va_arg(ap, unsigned int)));
	if (c == '%')
		return (ft_putcharcount_fd(fd, '%'));
	if (c == 'f')
		return (ft_putfloat_fd(fd, va_arg(ap, double), 2));
	return (0);
}
NAME	= ft_printf_fd.a

CC	= cc
CFLAGS	= -Wall -Wextra -Werror
AR	= ar rcs
RM	= rm -f

SRC	=	ft_printf_fd.c ft_which_index.c ft_putstrcount_fd.c\
		ft_putcharcount_fd.c ft_puthexacount_fd.c ft_putuphexacount_fd.c ft_putnbrcount_fd.c\
		ft_putnbru_fd.c ft_adress_fd.c ft_putfloat_fd.c\

OBJ	= $(SRC:.c=.o)

all: $(NAME)

$(NAME): $(OBJ)
	$(AR) $(NAME) $(OBJ)

%.o: %.c ft_printf_fd.h
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	$(RM) $(OBJ)

fclean: clean
	$(RM) $(NAME)

re: fclean all

.PHONY: all clean fclean re


#include "ft_printf_fd.h"
#include <stdio.h>

int main(void)
{
    // Test sur stdout (1)
    ft_printf_fd(1, "Ceci va dans stdout (comme sa, pb...)\n");
    
    // Test sur stderr (2)
    ft_printf_fd(2, "[bench] Ceci va dans stderr (statistiques)\n");
    
    return (0);
}